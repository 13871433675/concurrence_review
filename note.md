1.如何减少上下文切换？
无锁并发编程：
多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一
些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。 
CAS算法：
Java的Atomic包使用CAS算法来更新数据，而不需要加锁。
最少线程：避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。
使用协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。

2.并发编程的挑战？
注意多线程环境中上下文的切换会影响并发效率
死锁：两个线程互相等待对方的锁
资源的限制：网络带宽，磁盘IO速度（使用集群） / 软件资源限制（数据库连接，socket限制），使用连接池，在调用接口的时候只建立一个连接

3.synchronized的实现原理与应用

同步的基础：Java中的每一个对象都可以作为锁
普通同步方法：锁的是当前的实例对象
静态同步方法：锁的是当前类的Class对象
同步方法块：锁的是Synchronized括号里配置的对象

JVM基于进入和退出monitor对象来实现方法同步和代码块同步

synchronized用的锁是存在Java对象头里面的

4.锁的升级和对比
锁的四种状态：无锁-->偏向锁-->轻量级锁-->重量级锁  （竞争情况越来越激烈）
原则：锁可以升级但不能降级，以为这偏向锁升级程轻量级锁后不能降级为偏心锁。目的是为了提高获得锁和释放锁的效率

